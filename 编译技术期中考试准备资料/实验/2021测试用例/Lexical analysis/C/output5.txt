CONSTTK const
INTTK int
IDENFR zero
ASSIGN =
INTCON 0
COMMA ,
IDENFR one
ASSIGN =
PLUS +
INTCON 1
COMMA ,
IDENFR minus_one
ASSIGN =
MINU -
INTCON 1
SEMICN ;
CONSTTK const
INTTK int
IDENFR two
ASSIGN =
INTCON 2
SEMICN ;
CONSTTK const
INTTK int
IDENFR times
ASSIGN =
IDENFR zero
SEMICN ;
INTTK int
IDENFR while_times
ASSIGN =
IDENFR zero
SEMICN ;
INTTK int
IDENFR groups
ASSIGN =
INTCON 10
SEMICN ;
INTTK int
IDENFR get_max
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
COMMA ,
INTTK int
IDENFR c
RPARENT )
LBRACE {
IDENFR a
DIV /
IDENFR b
SEMICN ;
INTTK int
IDENFR max
ASSIGN =
IDENFR a
SEMICN ;
IFTK if
LPARENT (
IDENFR b
GRE >
IDENFR max
RPARENT )
LBRACE {
IDENFR max
ASSIGN =
IDENFR b
SEMICN ;
IFTK if
LPARENT (
IDENFR c
GRE >
IDENFR max
RPARENT )
LBRACE {
IDENFR max
ASSIGN =
IDENFR c
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
IDENFR max
SEMICN ;
RBRACE }
VOIDTK void
IDENFR while_times_cal
LPARENT (
RPARENT )
LBRACE {
IDENFR while_times
ASSIGN =
IDENFR while_times
PLUS +
INTCON 1
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
IDENFR is_prime
LPARENT (
INTTK int
IDENFR in
RPARENT )
LBRACE {
INTTK int
IDENFR result
ASSIGN =
IDENFR zero
SEMICN ;
INTTK int
IDENFR item
ASSIGN =
IDENFR two
SEMICN ;
LBRACE {
RBRACE }
IFTK if
LPARENT (
IDENFR in
EQL ==
INTCON 2
RPARENT )
LBRACE {
IDENFR result
ASSIGN =
IDENFR one
SEMICN ;
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
WHILETK while
LPARENT (
IDENFR item
LSS <
IDENFR in
RPARENT )
LBRACE {
IDENFR while_times_cal
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR in
MOD %
IDENFR item
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR result
ASSIGN =
IDENFR zero
SEMICN ;
BREAKTK break
SEMICN ;
RBRACE }
IDENFR result
ASSIGN =
IDENFR one
SEMICN ;
IDENFR item
ASSIGN =
IDENFR item
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
IDENFR result
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR input
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "16061069\n"
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "input an integer,judge if it is prime number,10 groups in total\n"
RPARENT )
SEMICN ;
WHILETK while
LPARENT (
IDENFR groups
NEQ !=
INTCON 0
RPARENT )
LBRACE {
IDENFR while_times_cal
LPARENT (
RPARENT )
SEMICN ;
IDENFR input
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR input
LEQ <=
INTCON 0
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "input > 0 is needed\n"
RPARENT )
SEMICN ;
IDENFR groups
ASSIGN =
IDENFR groups
MINU -
INTCON 1
SEMICN ;
CONTINUETK continue
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR input
EQL ==
INTCON 1
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "1 is not concerned\n"
RPARENT )
SEMICN ;
IDENFR groups
ASSIGN =
IDENFR groups
MINU -
INTCON 1
SEMICN ;
CONTINUETK continue
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
IDENFR is_prime
LPARENT (
IDENFR input
RPARENT )
GEQ >=
INTCON 1
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "%d is a prime number\n"
COMMA ,
IDENFR input
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "%d is not a prime number\n"
COMMA ,
IDENFR input
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
IDENFR groups
ASSIGN =
IDENFR groups
MINU -
INTCON 1
SEMICN ;
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "while times is %d in total\n"
COMMA ,
IDENFR while_times
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
