# 申优文档 权尚浩然 21371064

## 中间代码

提及优化，避不开中间代码的选择。

我一开始并不知道LLVM有多好使，而是自己写中间代码。我重构过一次中间代码——在代码生成作业时，我中间代码的设计基本是按当前需求进行设计，种类繁多而且很难统一，生成代码时或许不用想太多问题，但在优化过程中它很难操控的弊端便显现了。从“生成代码”到“优化代码”的需求改变让我不得不重构中间代码，在之后的一版中间代码中，我基本是按照四元式构建的，当时还没有看到郭佬的文档，但看到之后发现与郭佬很多都不谋而合。

构建中间代码过程中，是很难超前想到怎么构建会更加利于之后的优化，只能是先尝试，然后遇到细节，发现或许那样更好，再更改，再尝试，再更改。

我目前对最后这版中间代码大体满意，但对于数组存取上还有改进空间。我会用[] z x y表示z=x[y]，[]= z x y表示z[x]=y，但我现在想改成*z x与&z x，即直接用x变量存取z地址元素，这样好处有三：

​		一是对地址的加减可以进行表达式优化了；

​		二是地址操作的中间代码更加简洁，便于处理；

​		三是在函数内联时，也更好直接赋值地址。

## SSA（静态单赋值）

[SSA 参考论文](https://www.cs.utexas.edu/~pingali/CS380C/2010/papers/ssaCytron.pdf)

#### 大致思想

SSA是我写的一个主要优化。写它的一大动机是我看到我的中间代码上，有很多明显冗余的赋值指令，比如如果我进行一次d=a+b+c; 我会先把a+b结果计算出来后，再赋值给一个t1，再与c相加，SSA可以优化掉这种情况。

SSA（静态单赋值）核心思想是，在中间代码基础上，通过对变量重命名将一个变量分裂成多个，使得重命名后的每一个变量在中间代码中刚好只被赋值一次。根据这个定义可以发现，单纯做SSA起不到优化的效果，但SSA处理后的中间代码具有的“每个变量只被定义一次”的这个优良性质使得很多其它优化在这基础上更加容易、有效。

实施过程中，我们从前往后考虑中间代码，对每个变量开一个ｍａｐ容器，每次遇到对其的重定义，我们就给它换一个新的编号，以后再使用时就用新编号。而具体情况并不是简单从前到后，而是要考虑代码运行的从前到后顺序，我们要建立出流图，并且在流图的基础上建出基本块的支配树，先序遍历支配树就是代码运行从前到后的顺序了。

#### phi函数

上面的操作还会遇到一个问题，当支配树上两个节点（支配树的节点是基本块）同时流向一个节点时，而且它们定义了同样一个变量，对于它们流向的这个基本块这个变量我们不知道该使用哪个前趋的编号。这种情况不会很多，但在循环过程中，或是多个条件判断过程中，很多重复使用的变量会有这个问题。例如下面这个例子:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201220200235271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4ODc2MTE0,size_16,color_FFFFFF,t_30#pic_center)

对变量重命名后，0号和1号语句中的y会被分配不同的编号，此时3号语句我们不知y变量该使用上面的哪一个。

解决的办法是引入phi函数。

我们用一种方法求得什么时候会产生这样的冲突，然后，用上面的例子，我们在0和1号语句后面插入一个$y_3=y_1$或是$y_3=y_2$,这样在下面我们就可以直接使用$y_3$了。而可能出现这样的冲突的地方被称作一个基本块的支配边界,可以用下面的代码求出.

![image-20221219103227959](C:\Users\hao\AppData\Roaming\Typora\typora-user-images\image-20221219103227959.png)

有了支配边界,我们便可以对每一个变量求出哪里需要插入phi函数,用下面的代码求出

![image-20221219103329340](C:\Users\hao\AppData\Roaming\Typora\typora-user-images\image-20221219103329340.png)

由于需要引入phi函数的变量出现位置多、情况复杂,性质也比较特殊,成了SSA中最容易出错的地方．

## GVN(全局值编号)

在SSA的基础上,可以进行GVN(全局值编号)优化,它的效果相当于复写传播+常量传播+公共子表达式删除.具体地,我们先序遍历支配树,将每个赋值的左值后面的使用替换为右值,如果右值是变量,就是复写传播,如果是常量,就是常量传播.

对于公共子表达式删除,就是将每个表达式存成一个字符串放到map容器里,后面遇到同样的表达式计算就可以直接改为用之前的左值进行复写.这个操作也需要在先序遍历的支配树上进行,注意需要对map容器进行保存以方便回溯.

可以发现,能进行GVN优化是需要SSA每一个变量只被定义一次这个性质的,它保证了我们每一个变量在定义后便不再改变.

## 死代码删除

仅仅做了上面的优化实质上不会减少中间代码的数量,我们需要最后清理掉没有使用的定义语句才达到了做这些事情的意义.我认为SSA+GVN便是把中间代码的信息浓缩到一些代码上,而死代码删除则是把浓缩过程中不再保留信息的代码删除,完成优化作用.